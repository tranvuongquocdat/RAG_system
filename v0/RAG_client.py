import gradio as gr
import requests
import json
from typing import List, Optional
import time

# Server configuration
SERVER_URL = "http://localhost:8000"

# Th√™m bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u API key
api_key = ""

def set_api_key(user_api_key):
    global api_key
    api_key = user_api_key
    return f"ƒê√£ l∆∞u API key: {user_api_key[:4]}***"

def upload_documents(files):
    """Upload multiple documents to server"""
    if not files:
        return "Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt t√†i li·ªáu!", None
    
    results = []
    progress_messages = []
    
    for i, file in enumerate(files):
        try:
            progress_messages.append(f"ƒêang x·ª≠ l√Ω t√†i li·ªáu {i+1}/{len(files)}: {file.name}")
            yield "\n".join(progress_messages), None
            
            with open(file.name, "rb") as f:
                files_data = {"file": (file.name.split("/")[-1], f, "application/octet-stream")}
                response = requests.post(
                    f"{SERVER_URL}/documents/",
                    files=files_data,
                    headers={"X-GEMINI-API-KEY": api_key} if api_key else None
                )
            
            if response.status_code == 200:
                result = response.json()
                progress_messages.append(f"‚úì {file.name.split('/')[-1]}: ƒê√£ th√™m {result['chunks_count']} chunks")
                results.append(f"‚úì {file.name.split('/')[-1]}: Success")
            elif response.status_code == 409:
                progress_messages.append(f"‚ö† {file.name.split('/')[-1]}: T√†i li·ªáu ƒë√£ t·ªìn t·∫°i")
                results.append(f"‚ö† {file.name.split('/')[-1]}: Already exists")
            else:
                error_msg = response.json().get("detail", "Unknown error")
                progress_messages.append(f"‚úó {file.name.split('/')[-1]}: L·ªói - {error_msg}")
                results.append(f"‚úó {file.name.split('/')[-1]}: Error")
                
        except Exception as e:
            progress_messages.append(f"‚úó {file.name.split('/')[-1]}: Exception - {str(e)}")
            results.append(f"‚úó {file.name.split('/')[-1]}: Exception")
        
        yield "\n".join(progress_messages), None
    
    # Final result
    final_message = "\n".join(progress_messages) + "\n\n=== K·∫æT QUA CU·ªêI C√ôNG ==="
    updated_docs = get_documents_list()
    yield final_message, updated_docs

def get_documents_list():
    """Get list of documents from server"""
    try:
        response = requests.get(f"{SERVER_URL}/documents/")
        if response.status_code == 200:
            documents = response.json()
            if not documents:
                return [["Kh√¥ng c√≥ t√†i li·ªáu n√†o", "", "", ""]]
            
            return [[doc["name"], doc["id"][:8], doc["created_at"][:19], str(doc["chunks_count"])] 
                   for doc in documents]
        else:
            return [["L·ªói khi t·∫£i danh s√°ch t√†i li·ªáu", "", "", ""]]
    except Exception as e:
        return [[f"L·ªói: {str(e)}", "", "", ""]]

def delete_documents(selected_docs):
    """Delete selected documents"""
    if selected_docs is None or len(selected_docs) == 0:
        return "Vui l√≤ng ch·ªçn t√†i li·ªáu ƒë·ªÉ x√≥a!", None

    results = []
    for doc_item in selected_docs:  # Renamed to avoid shadowing
        doc_name = "Unknown"  # Initialize to avoid UnboundLocalError
        try:
            # Handle both list and tuple formats
            if isinstance(doc_item, (list, tuple)) and len(doc_item) >= 2:
                doc_name, doc_id_short = doc_item[0], doc_item[1]
            else:
                results.append(f"‚úó Invalid document format: {doc_item}")
                continue
            
            # Get full document ID
            response = requests.get(f"{SERVER_URL}/documents/")
            if response.status_code == 200:
                documents = response.json()
                full_doc_id = None
                for document in documents:  # Renamed to avoid shadowing
                    if document["id"].startswith(doc_id_short) and document["name"] == doc_name:
                        full_doc_id = document["id"]
                        break
                
                if full_doc_id:
                    delete_response = requests.delete(f"{SERVER_URL}/documents/{full_doc_id}")
                    if delete_response.status_code == 200:
                        results.append(f"‚úì ƒê√£ x√≥a: {doc_name}")
                    else:
                        results.append(f"‚úó L·ªói khi x√≥a: {doc_name}")
                else:
                    results.append(f"‚úó Kh√¥ng t√¨m th·∫•y: {doc_name}")
            else:
                results.append(f"‚úó L·ªói k·∫øt n·ªëi server khi x√≥a: {doc_name}")
            
        except Exception as e:
            results.append(f"‚úó Exception: {doc_name} - {str(e)}")
    
    result_message = "\n".join(results)
    updated_docs = get_documents_list()
    # Ensure all rows are lists, not tuples
    updated_docs = [list(row) for row in updated_docs]
    return result_message, updated_docs

def query_knowledge_base(query, instruction):
    """Query the knowledge base"""
    if not query.strip():
        return "Vui l√≤ng nh·∫≠p c√¢u h·ªèi!", "", ""
    
    global api_key
    try:
        payload = {
            "query": query,
            "instruction": instruction if instruction.strip() else None,
            "top_k": 5
        }
        
        response = requests.post(
            f"{SERVER_URL}/query/",
            json=payload,
            headers={"X-GEMINI-API-KEY": api_key} if api_key else None
        )
        
        if response.status_code == 200:
            result = response.json()
            
            # Format relevant chunks
            chunks_text = ""
            if result["relevant_chunks"]:
                for i, (chunk, source) in enumerate(zip(result["relevant_chunks"], result["sources"])):
                    chunks_text += f"**Chunk {i+1} (t·ª´ {source}):**\n{chunk}\n\n"
            
            # Format sources
            sources_text = ""
            if result["sources"]:
                unique_sources = list(set(result["sources"]))
                sources_text = "**Ngu·ªìn t√†i li·ªáu:** " + ", ".join(unique_sources)
            
            return result["answer"], chunks_text, sources_text
        
        else:
            error_detail = response.json().get("detail", "Unknown error")
            return f"L·ªói: {error_detail}", "", ""
            
    except Exception as e:
        return f"L·ªói k·∫øt n·ªëi: {str(e)}", "", ""

def refresh_documents_list():
    """Refresh the documents list"""
    docs = get_documents_list()
    # Ensure dropdown choices are tuples for proper handling
    dropdown_choices = [(doc[0], doc[1]) for doc in docs if len(doc) >= 2]
    return docs, dropdown_choices

def check_server_status():
    """Check if server is running"""
    try:
        response = requests.get(f"{SERVER_URL}/")
        if response.status_code == 200:
            data = response.json()
            return f"‚úì Server ƒëang ho·∫°t ƒë·ªông\nüìÑ S·ªë t√†i li·ªáu: {data['documents_count']}\nüìù T·ªïng chunks: {data['total_chunks']}"
        else:
            return "‚úó Server c√≥ v·∫•n ƒë·ªÅ"
    except Exception as e:
        return f"‚úó Kh√¥ng th·ªÉ k·∫øt n·ªëi server: {str(e)}"

def get_documents_table():
    """Get documents list for table only"""
    return get_documents_list()

# Create Gradio interface
with gr.Blocks(title="H·ªá th·ªëng kho tri th·ª©c", theme=gr.themes.Soft()) as demo:
    gr.Markdown("# ü§ñ H·ªá th·ªëng kho tri th·ª©c")
    gr.Markdown("H·ªá th·ªëng s·ª≠ d·ª•ng LLM ƒë·ªÉ tr√≠ch xu·∫•t tri th·ª©c t·ª´ t√†i li·ªáu v√† tr·∫£ l·ªùi c√¢u h·ªèi d·ª±a tr√™n t√†i li·ªáu ƒë√≥")
    # Server status
    with gr.Row():
        status_btn = gr.Button("üîç Ki·ªÉm tra Server", variant="secondary")
        status_output = gr.Textbox(label="Tr·∫°ng th√°i Server", interactive=False)
    
    status_btn.click(check_server_status, outputs=status_output)
    
    # Document management section
    with gr.Tab("üìÅ Qu·∫£n l√Ω T√†i li·ªáu"):
        with gr.Row():
            with gr.Column(scale=1):
                gr.Markdown("### Th√™m T√†i li·ªáu")
                file_input = gr.File(
                    label="Ch·ªçn t√†i li·ªáu (PDF, DOCX, TXT)",
                    file_count="multiple",
                    file_types=[".pdf", ".docx", ".txt"]
                )
                upload_btn = gr.Button("üì§ Th√™m v√†o Knowledge Base", variant="primary")
                upload_progress = gr.Textbox(label="Ti·∫øn tr√¨nh x·ª≠ l√Ω", lines=8, interactive=False)
            
            with gr.Column(scale=1):
                gr.Markdown("### Danh s√°ch T√†i li·ªáu")
                refresh_btn = gr.Button("üîÑ L√†m m·ªõi danh s√°ch")
                docs_table = gr.Dataframe(
                    headers=["T√™n t√†i li·ªáu", "ID", "Ng√†y t·∫°o", "S·ªë chunks"],
                    datatype=["str", "str", "str", "str"],
                    value=get_documents_list(),
                    interactive=True
                )
                
                delete_dropdown = gr.Dropdown(
                    label="Ch·ªçn t√†i li·ªáu ƒë·ªÉ x√≥a",
                    choices=[(doc[0], doc[1]) for doc in get_documents_list() if len(doc) >= 2],  # Tuples (T√™n, ID r√∫t g·ªçn)
                    multiselect=True,
                    allow_custom_value=True  # Add this to prevent warnings
                )
                delete_btn = gr.Button("üóëÔ∏è X√≥a t√†i li·ªáu ƒë√£ ch·ªçn", variant="stop")
                delete_result = gr.Textbox(label="K·∫øt qu·∫£ x√≥a", interactive=False)
    
    # Query section
    with gr.Tab("‚ùì Truy v·∫•n"):
        with gr.Column():
            query_input = gr.Textbox(
                label="C√¢u h·ªèi c·ªßa b·∫°n",
                placeholder="Nh·∫≠p c√¢u h·ªèi...",
                lines=2
            )
            instruction_input = gr.Textbox(
                label="Instruction (t√πy ch·ªçn)",
                placeholder="T√πy ch·ªânh c√°ch AI tr·∫£ l·ªùi...",
                lines=3
            )
            query_btn = gr.Button("üîç T√¨m ki·∫øm", variant="primary")
            
            with gr.Row():
                with gr.Column(scale=2):
                    answer_output = gr.Textbox(
                        label="üìù C√¢u tr·∫£ l·ªùi",
                        lines=8,
                        interactive=False
                    )
                with gr.Column(scale=1):
                    sources_output = gr.Textbox(
                        label="üìö Ngu·ªìn t√†i li·ªáu",
                        lines=3,
                        interactive=False
                    )
            
            chunks_output = gr.Textbox(
                label="üìÑ C√°c ƒëo·∫°n vƒÉn li√™n quan",
                lines=10,
                interactive=False
            )
    
    # Event handlers
    upload_btn.click(
        upload_documents,
        inputs=file_input,
        outputs=[upload_progress, docs_table]
    )
    
    refresh_btn.click(
        refresh_documents_list,
        outputs=[docs_table, delete_dropdown]
    )
    
    delete_btn.click(
        delete_documents,
        inputs=delete_dropdown,
        outputs=[delete_result, docs_table]
    )
    
    query_btn.click(
        query_knowledge_base,
        inputs=[query_input, instruction_input],
        outputs=[answer_output, chunks_output, sources_output]
    )

    # with gr.Row():
    #     api_key_input = gr.Textbox(label="Gemini API Key", type="password")
    #     save_api_btn = gr.Button("L∆∞u API Key")
    #     api_key_status = gr.Textbox(label="Tr·∫°ng th√°i API Key", interactive=False)
    # save_api_btn.click(set_api_key, inputs=api_key_input, outputs=api_key_status)
    
    # Auto-refresh documents list on startup
    demo.load(get_documents_table, outputs=docs_table)
    demo.load(check_server_status, outputs=status_output)

if __name__ == "__main__":
    demo.launch(
        server_name="0.0.0.0",
        server_port=7860,
        share=False,
        inbrowser=True
    )
"""
Database module for RAG system
Qu·∫£n l√Ω Qdrant vector database v√† c√°c operations li√™n quan
"""

import time
import uuid
from typing import List, Dict, Any, Optional, Union, Tuple
from datetime import datetime
from qdrant_client import QdrantClient
from qdrant_client.http import models
from qdrant_client.http.models import (
    Distance, VectorParams, PointStruct, Filter, 
    FieldCondition, MatchValue, Range, GeoBoundingBox,
    SearchParams, UpdateStatus
)
from langchain_qdrant import QdrantVectorStore
from langchain_core.documents import Document

from config import get_config
from utils import setup_logging
from embedding import EmbeddingManager

class QdrantManager:
    """
    Qu·∫£n l√Ω Qdrant vector database operations
    """
    
    def __init__(
        self, 
        host: Optional[str] = None,
        port: Optional[int] = None,
        api_key: Optional[str] = None,
        collection_name: Optional[str] = None
    ):
        """
        Kh·ªüi t·∫°o QdrantManager
        
        Args:
            host: Qdrant host (optional, s·∫Ω l·∫•y t·ª´ config)
            port: Qdrant port (optional, s·∫Ω l·∫•y t·ª´ config)
            api_key: Qdrant API key (optional)
            collection_name: T√™n collection (optional, s·∫Ω l·∫•y t·ª´ config)
        """
        self.config = get_config()
        self.logger = setup_logging(self.config.app.log_level, self.config.app.log_file)
        
        # S·ª≠ d·ª•ng config ho·∫∑c parameters
        self.host = host or self.config.qdrant.host
        self.port = port or self.config.qdrant.port
        self.api_key = api_key or self.config.qdrant.api_key
        self.collection_name = collection_name or self.config.qdrant.collection_name
        
        # Kh·ªüi t·∫°o Qdrant client
        self._initialize_client()
        
        self.logger.info(f"‚úÖ QdrantManager ƒë√£ kh·ªüi t·∫°o - Host: {self.host}:{self.port}")
    
    def _initialize_client(self) -> None:
        """Kh·ªüi t·∫°o Qdrant client"""
        try:
            # T·∫°o client
            if self.api_key:
                self.client = QdrantClient(
                    host=self.host,
                    port=self.port,
                    api_key=self.api_key
                )
            else:
                self.client = QdrantClient(
                    host=self.host,
                    port=self.port
                )
            
            # Test connection
            collections = self.client.get_collections()
            self.logger.info(f"‚úÖ K·∫øt n·ªëi Qdrant th√†nh c√¥ng. C√≥ {len(collections.collections)} collections")
            
        except Exception as e:
            self.logger.error(f"‚ùå L·ªói khi k·∫øt n·ªëi Qdrant: {str(e)}")
            raise
    
    def create_collection(
        self, 
        vector_size: int,
        distance_metric: str = "cosine",
        force_recreate: bool = False
    ) -> bool:
        """
        T·∫°o collection trong Qdrant
        
        Args:
            vector_size: K√≠ch th∆∞·ªõc vector
            distance_metric: Metric t√≠nh kho·∫£ng c√°ch (cosine, dot, euclidean)
            force_recreate: C√≥ x√≥a v√† t·∫°o l·∫°i collection n·∫øu ƒë√£ t·ªìn t·∫°i
        
        Returns:
            True n·∫øu t·∫°o th√†nh c√¥ng
        """
        try:
            # Ki·ªÉm tra collection ƒë√£ t·ªìn t·∫°i ch∆∞a
            collections = self.client.get_collections()
            collection_exists = any(
                col.name == self.collection_name 
                for col in collections.collections
            )
            
            if collection_exists:
                if force_recreate:
                    self.logger.info(f"üóëÔ∏è X√≥a collection c≈©: {self.collection_name}")
                    self.client.delete_collection(self.collection_name)
                else:
                    self.logger.info(f"‚úÖ Collection ƒë√£ t·ªìn t·∫°i: {self.collection_name}")
                    return True
            
            # Map distance metric
            distance_map = {
                "cosine": Distance.COSINE,
                "dot": Distance.DOT,
                "euclidean": Distance.EUCLID
            }
            
            distance = distance_map.get(distance_metric.lower(), Distance.COSINE)
            
            # T·∫°o collection
            self.client.create_collection(
                collection_name=self.collection_name,
                vectors_config=VectorParams(
                    size=vector_size,
                    distance=distance
                ),
                # C·∫•u h√¨nh t·ªëi ∆∞u cho performance
                optimizers_config=models.OptimizersConfigDiff(
                    default_segment_number=2
                ),
                hnsw_config=models.HnswConfigDiff(
                    payload_m=16,
                    m=0
                )
            )
            
            self.logger.info(f"‚úÖ ƒê√£ t·∫°o collection: {self.collection_name} (size: {vector_size}, metric: {distance_metric})")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå L·ªói khi t·∫°o collection: {str(e)}")
            return False
    
    def insert_documents(
        self, 
        documents: List[Dict[str, Any]],
        batch_size: int = 100
    ) -> bool:
        """
        Insert documents v√†o Qdrant
        
        Args:
            documents: Danh s√°ch documents v·ªõi embedding v√† metadata
            batch_size: K√≠ch th∆∞·ªõc batch ƒë·ªÉ insert
        
        Returns:
            True n·∫øu insert th√†nh c√¥ng
        """
        try:
            points = []
            
            for doc in documents:
                # T·∫°o point ID
                point_id = doc.get('id', str(uuid.uuid4()))
                
                # Vector embedding
                vector = doc.get('embedding', [])
                if not vector:
                    self.logger.warning(f"Document {point_id} kh√¥ng c√≥ embedding")
                    continue
                
                # Payload (metadata)
                payload = {
                    'content': doc.get('content', ''),
                    'filename': doc.get('filename', ''),
                    'document_type': doc.get('document_type', 'general'),
                    'chunk_id': doc.get('chunk_id', 0),
                    'created_at': doc.get('created_at', datetime.now().isoformat()),
                    'source': doc.get('source', ''),
                    'metadata': doc.get('metadata', {})
                }
                
                # T·∫°o point
                point = PointStruct(
                    id=point_id,
                    vector=vector,
                    payload=payload
                )
                points.append(point)
            
            # Insert theo batch
            total_inserted = 0
            for i in range(0, len(points), batch_size):
                batch_points = points[i:i + batch_size]
                
                operation_info = self.client.upsert(
                    collection_name=self.collection_name,
                    points=batch_points,
                    wait=True
                )
                
                if operation_info.status == UpdateStatus.COMPLETED:
                    total_inserted += len(batch_points)
                    self.logger.debug(f"‚úÖ ƒê√£ insert batch {i//batch_size + 1}: {len(batch_points)} documents")
                else:
                    self.logger.error(f"‚ùå L·ªói insert batch {i//batch_size + 1}")
            
            self.logger.info(f"‚úÖ ƒê√£ insert {total_inserted}/{len(documents)} documents v√†o Qdrant")
            return total_inserted == len(documents)
            
        except Exception as e:
            self.logger.error(f"‚ùå L·ªói khi insert documents: {str(e)}")
            return False
    
    def search_similar(
        self,
        query_vector: List[float],
        top_k: int = 5,
        score_threshold: float = 0.0,
        filters: Optional[Dict[str, Any]] = None
    ) -> List[Dict[str, Any]]:
        """
        T√¨m ki·∫øm documents t∆∞∆°ng ƒë·ªìng
        
        Args:
            query_vector: Vector c·ªßa query
            top_k: S·ªë l∆∞·ª£ng k·∫øt qu·∫£ tr·∫£ v·ªÅ
            score_threshold: Ng∆∞·ª°ng ƒëi·ªÉm t·ªëi thi·ªÉu
            filters: B·ªô l·ªçc metadata
        
        Returns:
            Danh s√°ch documents t∆∞∆°ng ƒë·ªìng
        """
        try:
            # T·∫°o filter n·∫øu c√≥
            query_filter = None
            if filters:
                conditions = []
                
                for key, value in filters.items():
                    if isinstance(value, str):
                        conditions.append(
                            FieldCondition(
                                key=key,
                                match=MatchValue(value=value)
                            )
                        )
                    elif isinstance(value, list):
                        conditions.append(
                            FieldCondition(
                                key=key,
                                match=MatchValue(any=value)
                            )
                        )
                    elif isinstance(value, dict) and 'range' in value:
                        range_filter = value['range']
                        conditions.append(
                            FieldCondition(
                                key=key,
                                range=Range(
                                    gte=range_filter.get('gte'),
                                    lte=range_filter.get('lte')
                                )
                            )
                        )
                
                if conditions:
                    query_filter = Filter(must=conditions)
            
            # Th·ª±c hi·ªán search
            search_result = self.client.search(
                collection_name=self.collection_name,
                query_vector=query_vector,
                query_filter=query_filter,
                limit=top_k,
                score_threshold=score_threshold,
                with_payload=True,
                with_vectors=False
            )
            
            # Format k·∫øt qu·∫£
            results = []
            for hit in search_result:
                result = {
                    'id': hit.id,
                    'score': hit.score,
                    'content': hit.payload.get('content', ''),
                    'filename': hit.payload.get('filename', ''),
                    'document_type': hit.payload.get('document_type', ''),
                    'chunk_id': hit.payload.get('chunk_id', 0),
                    'metadata': hit.payload.get('metadata', {}),
                    'source': hit.payload.get('source', '')
                }
                results.append(result)
            
            self.logger.debug(f"‚úÖ T√¨m th·∫•y {len(results)} documents t∆∞∆°ng ƒë·ªìng")
            return results
            
        except Exception as e:
            self.logger.error(f"‚ùå L·ªói khi search: {str(e)}")
            return []
    
    def delete_documents(
        self, 
        document_ids: Optional[List[str]] = None,
        filters: Optional[Dict[str, Any]] = None
    ) -> bool:
        """
        X√≥a documents t·ª´ Qdrant
        
        Args:
            document_ids: Danh s√°ch IDs c·∫ßn x√≥a (optional)
            filters: B·ªô l·ªçc ƒë·ªÉ x√≥a theo ƒëi·ªÅu ki·ªán (optional)
        
        Returns:
            True n·∫øu x√≥a th√†nh c√¥ng
        """
        try:
            if document_ids:
                # X√≥a theo IDs
                operation_info = self.client.delete(
                    collection_name=self.collection_name,
                    points_selector=models.PointIdsList(
                        points=document_ids
                    ),
                    wait=True
                )
            elif filters:
                # X√≥a theo filters
                conditions = []
                for key, value in filters.items():
                    conditions.append(
                        FieldCondition(
                            key=key,
                            match=MatchValue(value=value)
                        )
                    )
                
                query_filter = Filter(must=conditions)
                operation_info = self.client.delete(
                    collection_name=self.collection_name,
                    points_selector=models.FilterSelector(
                        filter=query_filter
                    ),
                    wait=True
                )
            else:
                self.logger.error("C·∫ßn cung c·∫•p document_ids ho·∫∑c filters ƒë·ªÉ x√≥a")
                return False
            
            success = operation_info.status == UpdateStatus.COMPLETED
            if success:
                self.logger.info("‚úÖ ƒê√£ x√≥a documents th√†nh c√¥ng")
            else:
                self.logger.error("‚ùå L·ªói khi x√≥a documents")
            
            return success
            
        except Exception as e:
            self.logger.error(f"‚ùå L·ªói khi x√≥a documents: {str(e)}")
            return False
    
    def get_collection_info(self) -> Dict[str, Any]:
        """
        L·∫•y th√¥ng tin v·ªÅ collection
        
        Returns:
            Dictionary ch·ª©a th√¥ng tin collection
        """
        try:
            collection_info = self.client.get_collection(self.collection_name)
            
            info = {
                'name': collection_info.config.params.vectors.size,
                'vector_size': collection_info.config.params.vectors.size,
                'distance_metric': collection_info.config.params.vectors.distance.name,
                'points_count': collection_info.points_count,
                'segments_count': collection_info.segments_count,
                'status': collection_info.status.name,
                'optimizer_status': collection_info.optimizer_status.name if collection_info.optimizer_status else 'N/A'
            }
            
            return info
            
        except Exception as e:
            self.logger.error(f"‚ùå L·ªói khi l·∫•y th√¥ng tin collection: {str(e)}")
            return {}
    
    def count_documents(self, filters: Optional[Dict[str, Any]] = None) -> int:
        """
        ƒê·∫øm s·ªë l∆∞·ª£ng documents
        
        Args:
            filters: B·ªô l·ªçc (optional)
        
        Returns:
            S·ªë l∆∞·ª£ng documents
        """
        try:
            if filters:
                # Count v·ªõi filter
                conditions = []
                for key, value in filters.items():
                    conditions.append(
                        FieldCondition(
                            key=key,
                            match=MatchValue(value=value)
                        )
                    )
                
                query_filter = Filter(must=conditions)
                result = self.client.count(
                    collection_name=self.collection_name,
                    count_filter=query_filter
                )
            else:
                # Count t·∫•t c·∫£
                result = self.client.count(collection_name=self.collection_name)
            
            return result.count
            
        except Exception as e:
            self.logger.error(f"‚ùå L·ªói khi ƒë·∫øm documents: {str(e)}")
            return 0
    
    def update_document_metadata(
        self, 
        document_id: str, 
        metadata: Dict[str, Any]
    ) -> bool:
        """
        C·∫≠p nh·∫≠t metadata c·ªßa document
        
        Args:
            document_id: ID c·ªßa document
            metadata: Metadata m·ªõi
        
        Returns:
            True n·∫øu c·∫≠p nh·∫≠t th√†nh c√¥ng
        """
        try:
            operation_info = self.client.set_payload(
                collection_name=self.collection_name,
                payload=metadata,
                points=[document_id],
                wait=True
            )
            
            success = operation_info.status == UpdateStatus.COMPLETED
            if success:
                self.logger.debug(f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t metadata cho document: {document_id}")
            else:
                self.logger.error(f"‚ùå L·ªói c·∫≠p nh·∫≠t metadata cho document: {document_id}")
            
            return success
            
        except Exception as e:
            self.logger.error(f"‚ùå L·ªói khi c·∫≠p nh·∫≠t metadata: {str(e)}")
            return False

class QdrantVectorStoreManager:
    """
    Wrapper cho LangChain QdrantVectorStore
    T√≠ch h·ª£p v·ªõi LangChain ecosystem
    """
    
    def __init__(
        self, 
        qdrant_manager: QdrantManager, 
        embedding_manager: EmbeddingManager
    ):
        """
        Kh·ªüi t·∫°o QdrantVectorStoreManager
        
        Args:
            qdrant_manager: QdrantManager instance
            embedding_manager: EmbeddingManager instance
        """
        self.qdrant_manager = qdrant_manager
        self.embedding_manager = embedding_manager
        self.logger = qdrant_manager.logger
        
        # T·∫°o LangChain vector store
        self.vector_store = QdrantVectorStore(
            client=qdrant_manager.client,
            collection_name=qdrant_manager.collection_name,
            embeddings=embedding_manager.embeddings
        )
        
        self.logger.info("‚úÖ QdrantVectorStoreManager ƒë√£ kh·ªüi t·∫°o")
    
    def add_documents(self, documents: List[Document]) -> List[str]:
        """
        Th√™m LangChain Documents v√†o vector store
        
        Args:
            documents: Danh s√°ch LangChain Documents
        
        Returns:
            Danh s√°ch IDs c·ªßa documents ƒë√£ th√™m
        """
        try:
            ids = self.vector_store.add_documents(documents)
            self.logger.info(f"‚úÖ ƒê√£ th√™m {len(documents)} documents v√†o vector store")
            return ids
            
        except Exception as e:
            self.logger.error(f"‚ùå L·ªói khi th√™m documents: {str(e)}")
            return []
    
    def similarity_search(
        self, 
        query: str, 
        k: int = 5,
        filter: Optional[Dict[str, Any]] = None
    ) -> List[Document]:
        """
        T√¨m ki·∫øm documents t∆∞∆°ng ƒë·ªìng v·ªõi query
        
        Args:
            query: Query string
            k: S·ªë l∆∞·ª£ng k·∫øt qu·∫£
            filter: B·ªô l·ªçc metadata
        
        Returns:
            Danh s√°ch LangChain Documents
        """
        try:
            docs = self.vector_store.similarity_search(
                query=query,
                k=k,
                filter=filter
            )
            
            self.logger.debug(f"‚úÖ T√¨m th·∫•y {len(docs)} documents cho query: {query[:50]}...")
            return docs
            
        except Exception as e:
            self.logger.error(f"‚ùå L·ªói khi search: {str(e)}")
            return []
    
    def similarity_search_with_score(
        self, 
        query: str, 
        k: int = 5,
        filter: Optional[Dict[str, Any]] = None
    ) -> List[Tuple[Document, float]]:
        """
        T√¨m ki·∫øm documents v·ªõi similarity scores
        
        Args:
            query: Query string
            k: S·ªë l∆∞·ª£ng k·∫øt qu·∫£
            filter: B·ªô l·ªçc metadata
        
        Returns:
            Danh s√°ch tuples (Document, score)
        """
        try:
            results = self.vector_store.similarity_search_with_score(
                query=query,
                k=k,
                filter=filter
            )
            
            self.logger.debug(f"‚úÖ T√¨m th·∫•y {len(results)} documents v·ªõi scores")
            return results
            
        except Exception as e:
            self.logger.error(f"‚ùå L·ªói khi search v·ªõi scores: {str(e)}")
            return []
    
    def as_retriever(self, **kwargs):
        """
        T·∫°o LangChain retriever t·ª´ vector store
        
        Returns:
            VectorStoreRetriever
        """
        return self.vector_store.as_retriever(**kwargs)

# Factory functions
def create_qdrant_manager(
    host: Optional[str] = None,
    port: Optional[int] = None,
    api_key: Optional[str] = None,
    collection_name: Optional[str] = None
) -> QdrantManager:
    """
    Factory function ƒë·ªÉ t·∫°o QdrantManager
    """
    return QdrantManager(
        host=host,
        port=port,
        api_key=api_key,
        collection_name=collection_name
    )

def create_vector_store_manager(
    qdrant_manager: QdrantManager,
    embedding_manager: EmbeddingManager
) -> QdrantVectorStoreManager:
    """
    Factory function ƒë·ªÉ t·∫°o QdrantVectorStoreManager
    """
    return QdrantVectorStoreManager(qdrant_manager, embedding_manager)
